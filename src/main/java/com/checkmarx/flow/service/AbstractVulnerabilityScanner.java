package com.checkmarx.flow.service;

import com.checkmarx.flow.config.FlowProperties;
import com.checkmarx.flow.dto.*;
import com.checkmarx.flow.dto.report.ScanReport;
import com.checkmarx.flow.exception.ExitThrowable;
import com.checkmarx.flow.exception.GitHubRepoUnavailableException;
import com.checkmarx.flow.exception.MachinaException;
import com.checkmarx.flow.exception.MachinaRuntimeException;
import com.checkmarx.flow.sastscanning.ScanRequestConverter;
import com.checkmarx.flow.utils.ScanUtils;
import com.checkmarx.flow.utils.ZipUtils;

import com.checkmarx.sdk.ShardManager.ShardSessionTracker;
import com.checkmarx.sdk.config.CxProperties;
import com.checkmarx.sdk.config.CxPropertiesBase;
import com.checkmarx.sdk.dto.ScanResults;
import com.checkmarx.sdk.dto.cx.CxProject;
import com.checkmarx.sdk.dto.cx.CxScanParams;
import com.checkmarx.sdk.exception.CheckmarxException;

import com.cx.restclient.ScannerClient;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.exception.ExceptionUtils;

import org.eclipse.jgit.api.errors.GitAPIException;
import org.springframework.stereotype.Service;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.*;
import java.util.concurrent.CompletableFuture;

import static com.checkmarx.flow.exception.ExitThrowable.exit;
import static com.checkmarx.sdk.config.Constants.UNKNOWN;
import static com.checkmarx.sdk.config.Constants.UNKNOWN_INT;

@Service
@Slf4j
@RequiredArgsConstructor
public abstract class AbstractVulnerabilityScanner implements VulnerabilityScanner {

    protected static final String SCAN_TYPE = CxProperties.CONFIG_PREFIX;
    protected static final String ERROR_BREAK_MSG = "Exiting with Error code 10 due to issues present";
    private static final String CXFLOW_SCAN_MSG = "CxFlow Automated Scan";

    protected final ResultsService resultsService;

    protected final HelperService helperService;
    protected final FlowProperties flowProperties;

    private final EmailService emailService;
    private final BugTrackerEventTrigger bugTrackerEventTrigger;
    protected final ProjectNameGenerator projectNameGenerator;

    protected ScanDetails scanDetails = null;
    private String sourcesPath = null;

    protected final GitHubService gitService;
    protected final GitLabService gitLabService;
    protected final BitBucketService bitBucketService;
    protected final ADOService adoService;
    protected final ShardSessionTracker sessionTracker;
    
    @Override
    public ScanResults scan(ScanRequest scanRequest) {
        ScanResults scanResults;
        log.info("--------------------- Initiating new {} scan ---------------------", SCAN_TYPE);
        
        setRequestParamsByProperties(scanRequest);
        checkScanSubmitEmailDelivery(scanRequest);

        try {
            Integer scanId;
            CxScanParams cxScanParams = getScanRequestConverter().toScanParams(scanRequest);
            Integer projectId = cxScanParams.getProjectId();

            log.info("Checking if there is any existing scan for Project: {}", projectId);
            Integer existingScanId = getCxGoClient().getScanIdOfExistingScanIfExists(projectId);

            if (existingScanId != UNKNOWN_INT) {
                if (flowProperties.getScanResubmit()) {
                    log.info("Existing ongoing scan with id {} found for Project : {}", existingScanId, projectId);
                    log.info("Aborting the ongoing scan with id {} for Project: {}", existingScanId, projectId);
                    getCxGoClient().cancelScan(existingScanId);
                    log.info("Resubmitting the scan for Project: {}", projectId);
                    scanId = getCxGoClient().createScan(cxScanParams, getComment(scanRequest));
                } else {
                    log.warn("Property scan-resubmit set to {} : New scan not submitted, due to existing ongoing scan for the same Project id {}", flowProperties.getScanResubmit(), projectId);
                    bugTrackerEventTrigger.triggerScanNotSubmittedBugTrackerEvent(scanRequest, getEmptyScanResults());
                    throw new CheckmarxException(String.format("Active Scan with Id %d already exists for Project: %d", existingScanId, projectId));
                }
            } else {
                scanId = getCxGoClient().createScan(cxScanParams, getComment(scanRequest));
            }

            BugTracker.Type bugTrackerType = bugTrackerEventTrigger.triggerBugTrackerEvent(scanRequest);
            if (bugTrackerType.equals(BugTracker.Type.NONE)) {
                scanDetails = handleNoneBugTrackerCase(scanRequest, null, scanId, projectId);
            } else {
                getCxGoClient().waitForScanCompletion(scanId);
                projectId = handleUnKnownProjectId(cxScanParams.getProjectId(), cxScanParams.getTeamId(), cxScanParams.getProjectName());
                scanDetails = new ScanDetails(projectId, scanId, null);
            }
            logRequest(scanRequest, scanId, null, OperationResult.successful());

            scanResults = getCxGoClient().getReportContentByScanId(scanId, scanRequest.getFilter());
            scanResults.setSastScanId(scanId);
            return scanResults;

        } catch (GitHubRepoUnavailableException e) {
            //the repository is unavailable - can happen for a push event of a deleted branch - nothing to do

            //the error message is printed when the exception is thrown
            //usually should occur during push event occurring on delete branch
            //therefore need to eliminate the scan process but do not want to create
            //an error stack trace in the log
            return getEmptyScanResults();

        } catch (Exception e) {
            log.error("SAST scan failed", e);
            OperationResult scanCreationFailure = new OperationResult(OperationStatus.FAILURE, e.getMessage());
            ScanReport report = new ScanReport(-1, scanRequest, scanRequest.getRepoUrl(), scanCreationFailure);
            report.log();
            return getEmptyScanResults();
        }
    }

    protected void setRequestParamsByProperties(ScanRequest scanRequest){
        overrideScanPreset(scanRequest);
        setIsIncremental(scanRequest);
        setExclusionProperties(scanRequest);
    }

    protected void overrideScanPreset(ScanRequest scanRequest) {
        if (StringUtils.isNotEmpty(scanRequest.getScanPreset())) {
            scanRequest.setScanPresetOverride(true);
        }else{
            scanRequest.setScanPreset(getCxPropertiesBase().getScanPreset());
        }
    }
    
    protected void setExclusionProperties(ScanRequest scanRequest) {
        if (scanRequest.getExcludeFiles() == null && StringUtils.isNotEmpty(getCxPropertiesBase().getExcludeFiles())) {
            scanRequest.setExcludeFiles(Arrays.asList(getCxPropertiesBase().getExcludeFiles().split(",")));
        }
        if (scanRequest.getExcludeFolders() == null && StringUtils.isNotEmpty(getCxPropertiesBase().getExcludeFolders())) {
            scanRequest.setExcludeFolders(Arrays.asList(getCxPropertiesBase().getExcludeFolders().split(",")));
        }
    }
    
    protected abstract ScanRequestConverter getScanRequestConverter() ;

    protected void setIsIncremental(ScanRequest scanRequest) {
        scanRequest.setIncremental(Optional.ofNullable(scanRequest.isIncremental())
                .orElse(getCxPropertiesBase().getIncremental()));
    }
    
    @Override
    public ScanResults scanCli(ScanRequest request, String scanType, File... files) {
        ScanResults scanResults = null;
        try {
            switch (scanType) {
                case "Scan-git-clone":
                    scanResults = scanRemoteRepo(request);
                    break;
                case "cxFullScan":
                    scanResults = scanLocalPath(request, files[0].getPath());
                    break;
                case "cxParse":
                    cxParseResults(request, files[0]);
                    break;
                case "cxBatch":
                    cxBatch(request);
                    break;
                default:
                    log.warn("Scanner does not support scanType of {}, ignoring.", scanType);
                    break;
            }
        } catch (ExitThrowable e) {
            throw new MachinaRuntimeException(e);
        }
        return scanResults;
    }

    protected abstract void cxParseResults(ScanRequest request, File file) throws ExitThrowable;

    protected abstract void cxBatch(ScanRequest request) throws ExitThrowable;

    @Override
    public ScanResults getLatestScanResults(ScanRequest request) {
        return getLatestScanResultsAsync(request, null).join();
    }

    private ScanResults getEmptyScanResults() {
        ScanResults scanResults;
        scanResults = new ScanResults();
        scanResults.setProjectId(UNKNOWN);
        scanResults.setProject(UNKNOWN);
        scanResults.setScanType(SCAN_TYPE);
        return scanResults;
    }
    

    public ScanDetails executeCxScan(ScanRequest request, File cxFile) throws MachinaException {

        String osaScanId;
        Integer scanId = null;
        Integer projectId;

        try {
            /*Check if team is provided*/
            String ownerId = getScanRequestConverter().determineTeamAndOwnerID(request);

            log.debug("Auto profiling is enabled");
            projectId = getScanRequestConverter().determinePresetAndProjectId(request, ownerId);

            CxScanParams params = getScanRequestConverter().prepareScanParamsObject(request, cxFile, ownerId, projectId);

            scanId = getCxGoClient().createScan(params, getComment(request));

            BugTracker.Type bugTrackerType = bugTrackerEventTrigger.triggerBugTrackerEvent(request);
            if (bugTrackerType.equals(BugTracker.Type.NONE)) {
                return handleNoneBugTrackerCase(request, cxFile, scanId, projectId);
            } else {
                getCxGoClient().waitForScanCompletion(scanId);
                projectId = handleUnKnownProjectId(projectId, ownerId, request.getProject());
                osaScanId = createOsaScan(request, projectId);

                if (osaScanId != null) {
                    logRequest(request, osaScanId, cxFile, OperationResult.successful());
                }
            }
        } catch (GitHubRepoUnavailableException e) {
            // The error message is printed when the exception is thrown.
            // Usually should occur during push event occurring on delete branch.
            // Therefore need to eliminate the scan process but do not want to create
            // an error stack trace in the log.
            return new ScanDetails(UNKNOWN_INT, UNKNOWN_INT, new CompletableFuture<>(), false);
        } catch (CheckmarxException | GitAPIException e) {
            String extendedMessage = treatFailure(request, cxFile, scanId, e);
            throw new MachinaException("Checkmarx Error Occurred: " + extendedMessage);
        }

        logRequest(request, scanId, cxFile, OperationResult.successful());

        this.scanDetails = new ScanDetails(projectId, scanId, osaScanId);
        return scanDetails;
    }

    protected abstract String createOsaScan(ScanRequest request, Integer projectId) throws GitAPIException, CheckmarxException;

    private String getComment(ScanRequest request){
        return  helperService.getCxComment(request, CXFLOW_SCAN_MSG);
    }

    private ScanResults scanLocalPath(ScanRequest request, String path) throws ExitThrowable {
        ScanResults results = null;
        try {
            String effectiveProjectName = projectNameGenerator.determineProjectName(request);
            request.setProject(effectiveProjectName);

            File zipFile = ZipUtils.zipToTempFile(path, flowProperties.getZipExclude());
            ScanDetails details = executeCxScan(request, zipFile);
            results = getCxGoClient().getReportContentByScanId(details.getScanId(), request.getFilter());

            log.debug("Deleting temp file {}", zipFile.getPath());
            Files.deleteIfExists(zipFile.toPath());
        } catch (IOException e) {
            log.error("Error occurred while attempting to zip path {}", path, e);
            exit(3);
        } catch (MachinaException | CheckmarxException e) {
            log.error("Error occurred", e);
            exit(3);
        }
        return results;
    }

    private ScanResults scanRemoteRepo(ScanRequest request) throws ExitThrowable {
        ScanResults results = null;
        try {
            String effectiveProjectName = projectNameGenerator.determineProjectName(request);
            request.setProject(effectiveProjectName);
            ScanDetails details = executeCxScan(request, null);
            results = getCxGoClient().getReportContentByScanId(details.getScanId(), request.getFilter());
        } catch (MachinaException | CheckmarxException e) {
            log.error("Error occurred", e);
            exit(3);
        }
        return results;
    }

  

 

 

    private String treatFailure(ScanRequest request, File cxFile, Integer scanId, Exception e) {
        String extendedMessage = ExceptionUtils.getMessage(e);
        log.error(extendedMessage, e);
        Thread.currentThread().interrupt();
        OperationResult scanCreationFailure = new OperationResult(OperationStatus.FAILURE, e.getMessage());
        logRequest(request, scanId, cxFile, scanCreationFailure);
        return extendedMessage;
    }

    private void logRequest(ScanRequest request, Integer scanId, File cxFile, OperationResult scanCreationResult) {
        ScanReport report = new ScanReport(scanId, request, getRepoUrl(request, cxFile), scanCreationResult);
        report.log();
    }

    private void logRequest(ScanRequest request, String scanId, File cxFile, OperationResult scanCreationResult) {
        ScanReport report = new ScanReport(scanId, request, getRepoUrl(request, cxFile), scanCreationResult);
        report.log();
    }

    private String getRepoUrl(ScanRequest request, File cxFile) {
        String repoUrl;

        if (sourcesPath != null) {
            //the folder to scan is supplied via -f flag in command line and it is located in the filesystem
            repoUrl = sourcesPath;
        } else if (cxFile != null) {
            //in general cxFile is a zip created by cxFlow using the folder supplied y -f
            //the use case when sourcePath is empty but cxFile is set is only for the test flow
            repoUrl = cxFile.getAbsolutePath();
        } else {
            //sources to scan are in the remote repository (GitHib, TFS ... etc)
            repoUrl = request.getRepoUrl();
        }
        return repoUrl;
    }

    private ScanDetails handleNoneBugTrackerCase(ScanRequest request, File cxFile, Integer scanId, Integer projectId) {
        log.info("Not waiting for scan completion as Bug Tracker type is NONE");
        CompletableFuture<ScanResults> results = CompletableFuture.completedFuture(null);
        logRequest(request, scanId, cxFile, OperationResult.successful());
        return new ScanDetails(projectId, scanId, results, false);
    }

    private Integer handleUnKnownProjectId(Integer projectId, String ownerId, String projectName) {
        if (projectId == UNKNOWN_INT) {
            projectId = getCxGoClient().getProjectId(ownerId, projectName); //get the project id of the updated or created project
        }
        return projectId;
    }

    private void checkScanSubmitEmailDelivery(ScanRequest scanRequest) {
        if (StringUtils.isNoneEmpty(scanRequest.getNamespace(), scanRequest.getRepoName(), scanRequest.getRepoUrl())) {
            emailService.sendScanSubmittedEmail(scanRequest);
        }
    }

 

    public CompletableFuture<ScanResults> getLatestScanResultsAsync(ScanRequest request, CxProject cxProject) {
        try {
            CxProject project;
            if (cxProject == null) {
                Integer projectId = getProjectId(request);
                if (projectId.equals(UNKNOWN_INT)) {
                    log.warn("No project found for {}", request.getProject());
                    return CompletableFuture.completedFuture(null);
                }
                project = getCxGoClient().getProject(projectId);

            } else {
                project = cxProject;
            }
            Integer scanId = getCxGoClient().getLastScanId(project.getId());
            if (scanId.equals(UNKNOWN_INT)) {
                log.warn("No Scan Results to process for project {}", project.getName());
                CompletableFuture<ScanResults> x = new CompletableFuture<>();
                x.complete(null);
                return x;
            }
            setCxFields(project, request);
            //null is passed for osaScanId as it is not applicable here and will be ignored
            return resultsService.processScanResultsAsync(request, project.getId(), scanId, null, request.getFilter());

        } catch (MachinaException | CheckmarxException e) {
            log.error("Error occurred while processing results for {}{}", request.getTeam(), request.getProject(), e);
            CompletableFuture<ScanResults> x = new CompletableFuture<>();
            x.completeExceptionally(e);
            return x;
        }
    }

    private Integer getProjectId(ScanRequest request) throws CheckmarxException {
        String team = request.getTeam();
        if (ScanUtils.empty(team)) {
            //if the team is not provided, use the default
            team = getCxPropertiesBase().getTeam();
            request.setTeam(team);
        }
        if (!team.startsWith(getCxPropertiesBase().getTeamPathSeparator())) {
            team = getCxPropertiesBase().getTeamPathSeparator().concat(team);
        }
        String teamId = getCxGoClient().getTeamId(team);
        return getCxGoClient().getProjectId(teamId, request.getProject());
    }

    private void setCxFields(CxProject project, ScanRequest request) {
        if (project == null) {
            return;
        }

        Map<String, String> fields = new HashMap<>();
        for (CxProject.CustomField field : project.getCustomFields()) {
            String name = field.getName();
            String value = field.getValue();
            if (StringUtils.isNoneEmpty(name, value)) {
                fields.put(name, value);
            }
        }
        if (!ScanUtils.empty(getCxPropertiesBase().getJiraProjectField())) {
            String jiraProject = fields.get(getCxPropertiesBase().getJiraProjectField());
            if (!ScanUtils.empty(jiraProject)) {
                request.getBugTracker().setProjectKey(jiraProject);
            }
        }
        if (!ScanUtils.empty(getCxPropertiesBase().getJiraIssuetypeField())) {
            String jiraIssuetype = fields.get(getCxPropertiesBase().getJiraIssuetypeField());
            if (!ScanUtils.empty(jiraIssuetype)) {
                request.getBugTracker().setIssueType(jiraIssuetype);
            }
        }
        if (!ScanUtils.empty(getCxPropertiesBase().getJiraCustomField()) &&
                (fields.get(getCxPropertiesBase().getJiraCustomField()) != null) && !fields.get(getCxPropertiesBase().getJiraCustomField()).isEmpty()) {
            request.getBugTracker().setFields(ScanUtils.getCustomFieldsFromCx(fields.get(getCxPropertiesBase().getJiraCustomField())));
        }

        if (!ScanUtils.empty(getCxPropertiesBase().getJiraAssigneeField())) {
            String assignee = fields.get(getCxPropertiesBase().getJiraAssigneeField());
            if (!ScanUtils.empty(assignee)) {
                request.getBugTracker().setAssignee(assignee);
            }
        }

        request.setCxFields(fields);
    }

    protected abstract CxPropertiesBase getCxPropertiesBase();

    public abstract ScannerClient getCxGoClient() ;
}
